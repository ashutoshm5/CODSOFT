# -*- coding: utf-8 -*-
"""Moive Gnere.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wV3M3dfnRqJ9c7zTt2LqqK7w4NGiNAf8
"""



import pandas as pd

# Load training data
try:
    train_df = pd.read_csv('/data/train_data.txt', sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Load test data
    test_df = pd.read_csv('/data/test_data.txt', sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Load test solution data
    test_solution_df = pd.read_csv('/data/test_data_solution.txt', sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Display the first few rows of each DataFrame to verify loading
    display(train_df.head())
    display(test_df.head())
    display(test_solution_df.head())
except FileNotFoundError:
    print("Make sure the data files are in the /data/ directory or update the file paths.")

"""# Task
Create a machine learning model to predict movie genres from plot summaries using the provided dataset files "description.txt", "test_data.txt", "test_data_solution.txt", and "train_data.txt". The code should be written in a style suitable for a beginner.

## Load the data

### Subtask:
Load the training and test data from the provided files.

**Reasoning**:
The subtask requires loading data from three text files into pandas DataFrames. I will use the `pd.read_csv` function to read each file, specifying the appropriate separator and column names as instructed.
"""

from google.colab import files
print("Choose your test data file to upload...")
uploaded_test = files.upload()
test_filename = next(iter(uploaded_test.keys()))
print("Uploaded test data:", test_filename)

print("\nChoose your test solution file to upload...")
uploaded_solution = files.upload()
test_solution_filename = next(iter(uploaded_solution.keys()))
print("Uploaded test solution data:", test_solution_filename)

# Prepare the test data using the same TF-IDF vectorizer
X_test = tfidf_vectorizer.transform(test_df['plot_summary'])

# Predict genres on the test data
print("Making predictions on the test data...")
predictions = model.predict(X_test)
print("Predictions complete.")

# Evaluate the model using the test solution data
from sklearn.metrics import accuracy_score, classification_report

# Compare predictions with the actual genres from the test solution
y_true = test_solution_df['genre']

# Calculate accuracy
accuracy = accuracy_score(y_true, predictions)
print(f"\nAccuracy: {accuracy:.2f}")

# Display classification report
print("\nClassification Report:")
print(classification_report(y_true, predictions))

from sklearn.linear_model import LogisticRegression

# Initialize the Logistic Regression model
# You can adjust hyperparameters like C, solver, etc.
model = LogisticRegression(max_iter=1000) # Increased max_iter for convergence

# Train the model
print("Training the model...")
model.fit(X_train, y_train)
print("Model training complete.")

# Prepare the test data using the same TF-IDF vectorizer
X_test = tfidf_vectorizer.transform(test_df['plot_summary'])

# Predict genres on the test data
print("Making predictions on the test data...")
predictions = model.predict(X_test)
print("Predictions complete.")

# Evaluate the model using the test solution data
from sklearn.metrics import accuracy_score, classification_report

# Compare predictions with the actual genres from the test solution
y_true = test_solution_df['genre']

# Calculate accuracy
accuracy = accuracy_score(y_true, predictions)
print(f"\nAccuracy: {accuracy:.2f}")

# Display classification report
print("\nClassification Report:")
print(classification_report(y_true, predictions))

import pandas as pd

# Load test data
try:
    test_df = pd.read_csv(test_filename, sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Load test solution data
    test_solution_df = pd.read_csv(test_solution_filename, sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Display the first few rows of each DataFrame to verify loading
    print("Test Data Head:")
    display(test_df.head())
    print("\nTest Solution Data Head:")
    display(test_solution_df.head())

except Exception as e:
    print(f"An error occurred: {e}")
    print("Please make sure the uploaded files are the correct test data and test solution data and the format (separator, columns) is correct.")

# Prepare the test data using the same TF-IDF vectorizer
X_test = tfidf_vectorizer.transform(test_df['plot_summary'])

# Predict genres on the test data
print("Making predictions on the test data...")
predictions = model.predict(X_test)
print("Predictions complete.")

# Evaluate the model using the test solution data
from sklearn.metrics import accuracy_score, classification_report

# Compare predictions with the actual genres from the test solution
y_true = test_solution_df['genre']

# Calculate accuracy
accuracy = accuracy_score(y_true, predictions)
print(f"\nAccuracy: {accuracy:.2f}")

# Display classification report
print("\nClassification Report:")
print(classification_report(y_true, predictions))

# Prepare the test data using the same TF-IDF vectorizer
X_test = tfidf_vectorizer.transform(test_df['plot_summary'])

# Predict genres on the test data
print("Making predictions on the test data...")
predictions = model.predict(X_test)
print("Predictions complete.")

# Evaluate the model using the test solution data
from sklearn.metrics import accuracy_score, classification_report

# Compare predictions with the actual genres from the test solution
y_true = test_solution_df['genre']

# Calculate accuracy
accuracy = accuracy_score(y_true, predictions)
print(f"\nAccuracy: {accuracy:.2f}")

# Display classification report
print("\nClassification Report:")
print(classification_report(y_true, predictions))

"""## Evaluate the model

### Subtask:
Evaluate how well the trained model performs on the test data.

## Choose a model

### Subtask:
Select a suitable machine learning model for classification.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Initialize the TfidfVectorizer
# max_features can be adjusted depending on the desired vocabulary size
tfidf_vectorizer = TfidfVectorizer(max_features=5000)

# Fit and transform the training data
X_train = tfidf_vectorizer.fit_transform(train_df['plot_summary'])

# Display the shape of the resulting TF-IDF matrix
print("Shape of TF-IDF matrix for training data:", X_train.shape)

# The target variable (genres)
y_train = train_df['genre']

"""## Prepare the text data

### Subtask:
Clean and transform the text data (movie plot summaries) so it can be used by a machine learning model.
"""

# Assuming the uploaded file is the training data and its name is stored in the 'filename' variable
# You might need to adjust the separator and column names based on your file's structure
try:
    train_df = pd.read_csv(filename, sep=':::', engine='python', names=['genre', 'plot_summary'])

    # Display info about the dataframe
    print("Training Data Info:")
    train_df.info()

    # Display the first few rows
    print("\nFirst 5 rows of the training data:")
    display(train_df.head())

    # Display the number of unique genres
    print("\nNumber of unique genres:", train_df['genre'].nunique())

    # Display the distribution of genres
    print("\nGenre distribution:")
    display(train_df['genre'].value_counts())

except Exception as e:
    print(f"An error occurred: {e}")
    print("Please make sure the uploaded file is the correct training data and the format (separator, columns) is correct.")

"""## Explore the data

### Subtask:
Take a look at the training data to understand its structure and content.

**Reasoning**:
The previous attempt failed because the file 'train_data.txt' was not found. I need to check if the files exist in the current directory. If they do not, I will assume they are in a different path and try again with the correct path. Based on the problem description in the original request, it is highly probable the files are available in the `/data/` directory.
"""